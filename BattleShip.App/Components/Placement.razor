@inject GameState GameState
@using BattleShip.Models

<div class="container-placement">

	@* les différents bateaux à placer *@
	<div class="list-boat">
		
		@if(GameState.fleetJ1 != null)
		{
			@foreach (var boat in GameState.fleetJ1.Boats)
			{
				<div class="boat">
					<p class="@(boat.IsAlive ? "alive" : "sunk")">
						@boat.Name - @boat.Size
					</p>
					<div class="group-btn">
						@if(!IsPlaced(boat.Symbol))
						{
							<button class="btn btn-primary" disabled="@(clic)" @onclick="() => SelectBoat(boat, false)" >
								Add Vertical
							</button>
							<button class="btn btn-primary" disabled="@(clic)" @onclick="() => SelectBoat(boat, true)" >
								Add Horizontal
							</button>
						}
						else {
							<button class="btn btn-danger" disabled="@(clic)" @onclick="() => DeleteBoat(boat)" >
								Delete
							</button>
						}
					</div>
				</div>
			}
		}
	</div>


	@* Notre grille de placement *@
	<div class="placement-grid">
		<div class="sub-title placement-title">
			<h3>Our GRID</h3>
		</div>
		<div class="grid-container">
			@if (GameState != null & GameState.GridJ1 != null & GameState.GridJ1[0][0] != '0')
			{
				@for (int row = 0; row < GameState.GridJ1.Length; row++)
				{
					var currentRow = row;
					<div class="grid-row pos-@row">
						@for (int col = 0; col < GameState.GridJ1[0].Length; col++)
						{
							var currentCol = col;
							<div class="grid-item pos-@row-@col pos-@col"
								@onclick="() => AddBoatToGrid(currentRow, currentCol, placementHorizontal)"
								@onmouseover="() => PreviewBoatPlacement(currentRow, currentCol)">
								
								<!-- Affiche l'image du bateau, soit celle de la grille réelle, soit celle de la prévisualisation -->
								@GetImageForCell(previewGrid, GameState.GridJ1, GameState.MaskedGridJ1, currentRow, currentCol)
							</div>
						}
					</div>
				}
			}
		</div>

		<div class="btn-grid-container">
			<button class="btn btn-primary" @onclick="PlaceBoatsRandomly">
				Placement Aléatoire
			</button>
			<button class="btn btn-primary" disabled="@(!EverythingIsPlaced())" @onclick="() => OnButtonClicked(GameState.fleetJ1)">
				Start
			</button>
		</div>
	</div>

</div>




@code {

	private bool clic;
	private Boat boatSelected;
	private bool placementHorizontal = true;
	private int? hoverRow = null;
	private int? hoverCol = null;


	[Parameter]
	public EventCallback<Models.Fleet> OnCallStart { get; set; }

	public char[][] previewGrid;

	protected override void OnInitialized()
	{
		// Créez une grille temporaire de la même taille que GameState.GridJ1
		Console.WriteLine($"eeee{GameState.GridJ1.Length} &&&&& eee");
		previewGrid = new char[GameState.GridJ1.Length][];
		for (int i = 0; i < GameState.GridJ1.Length; i++)
		{
			previewGrid[i] = new char[GameState.GridJ1[i].Length];
		}
	}

	private void PreviewBoatPlacement(int row, int col)
	{
		if (previewGrid.Length != GameState.GridJ1.Length)
		{
			/*for (int i = 0; i < pregrid.Length; i++)
			{
				pregrid[i] = grid1[i].ToArray();
			}
			*/
			previewGrid = new char[GameState.GridJ1.Length][];
			for (int i = 0; i < GameState.GridJ1.Length; i++)
			{
				previewGrid[i] = new char[GameState.GridJ1[i].Length];
			}
		}
		// Si un bateau est sélectionné, on ajoute temporairement le bateau à la grille virtuelle
		if (boatSelected != null)
		{
			// Vider la grille temporaire
			for (int i = 0; i < previewGrid.Length; i++)
			{
				for (int j = 0; j < previewGrid[i].Length; j++)
				{
					previewGrid[i][j] = '\u0000';
				}
			}

			// Placer le bateau dans la grille virtuelle (en fonction de l'orientation)
			if (placementHorizontal)
			{
				for (int i = 0; i < boatSelected.Size; i++)
				{
					if (col + i < previewGrid[0].Length) // Vérifie que la case est dans la grille
					{
						previewGrid[row][col + i] = boatSelected.Symbol;
					}
				}
			}
			else
			{
				for (int i = 0; i < boatSelected.Size; i++)
				{
					if (row + i < previewGrid.Length) // Vérifie que la case est dans la grille
					{
						previewGrid[row + i][col] = boatSelected.Symbol;
					}
				}
			}
		}
	}


	private async Task OnButtonClicked(Models.Fleet placedBoat)
	{
		if (OnCallStart.HasDelegate & EverythingIsPlaced())
		{
			await OnCallStart.InvokeAsync(placedBoat);
		}
	}

	private void PlaceBoatsRandomly()
	{
		var random = new Random();
		foreach (var boat in GameState.fleetJ1.Boats)
		{
			DeleteBoat(boat);
		}

		// Pour chaque bateau non placé, essaie de le placer aléatoirement
		foreach (var boat in GameState.fleetJ1.Boats)
		{
			bool placed = false;

			while (!placed)
			{
				// Génère des positions et orientations aléatoires
				int row = random.Next(0, GameState.GridJ1.Length);
				int col = random.Next(0, GameState.GridJ1[0].Length);
				bool isHorizontal = random.Next(2) == 0; // 0 pour horizontal, 1 pour vertical

				if (CanBePlaced(row, col, boat.Size, isHorizontal))
				{
					SelectBoat(boat, isHorizontal);
					AddBoatToGrid(row, col, isHorizontal);
					placed = true;
				}
			}
		}
	}


	private void SelectBoat(Boat boat, bool isHorizontal)
	{
		clic = true;
		boatSelected = boat;
		placementHorizontal = isHorizontal;
	}


	private void AddBoatToGrid(int row, int col, bool isHorizontal)
	{
		if (clic)
		{
			if (CanBePlaced(row, col, boatSelected.Size, isHorizontal))
			{
				// Placer le bateau dans la grille
				for (int i = 0; i < boatSelected.Size; i++)
				{
					if (isHorizontal)
					{
						GameState.GridJ1[row][col + i] = boatSelected.Symbol;
					}
					else
					{
						GameState.GridJ1[row + i][col] = boatSelected.Symbol;
					}
				}

				// Mettre à jour les coordonnées du bateau
				boatSelected.X = col;
				boatSelected.Y = row;
				boatSelected.Horizontal = isHorizontal;

				// Désactiver le mode de placement et le preview
				clic = false;

				// Réinitialiser la grille de prévisualisation
				ClearPreviewGrid();
			}
		}
	}

	// Méthode pour vider la grille de prévisualisation
	private void ClearPreviewGrid()
	{
		clic = false;
		boatSelected = null;
		for (int i = 0; i < previewGrid.Length; i++)
		{
			for (int j = 0; j < previewGrid[i].Length; j++)
			{
				previewGrid[i][j] = '\u0000'; // Effacer les bateaux du preview
			}
		}
	}


	private void DeleteBoat(Boat boat)
	{
		for (int x = 0; x < GameState.GridJ1.Length; x++)
		{
			for (int y = 0; y < GameState.GridJ1[x].Length; y++)
			{
				if (GameState.GridJ1[x][y] == boat.Symbol)
				{
					GameState.GridJ1[x][y] = '\u0000';
				}
			}
		}
		boat.X = -1;
		boat.Y = -1;
	}


	private bool IsPlaced(char symbol)
	{
		for (int x = 0; x < GameState.GridJ1.Length; x++)
		{
			for (int y = 0; y < GameState.GridJ1[x].Length; y++)
			{
				if (GameState.GridJ1[x][y] == symbol)
				{
					return true; 
				}
			}
		}
		return false;
	}


	private bool CanBePlaced(int row, int col, int size, bool isHorizontal)
	{
		if(isHorizontal) {
			if(col+size > GameState.GridJ1.Length | col < 0) {
				return false;
			}
			for(int i = 0; i < size; i++) {
				if (GameState.GridJ1[row][col+i] != '\u0000') {
					return false;
				}
			}
		}
		else {
			if(row+size > GameState.GridJ1.Length | row < 0) {
				return false;
			}
			for(int i = 0; i < size; i++) {
				if (GameState.GridJ1[row+i][col] != '\u0000') {
					return false;
				}
			}
		}
		return true;
	}


	private bool EverythingIsPlaced()
	{
		if (GameState == null){return false;}
		if (GameState.fleetJ1 == null){return false;}
		if (GameState.fleetJ1.Boats == null){return false;}
		
		foreach (var boat in GameState.fleetJ1.Boats)
		{
			if(boat.X == -1 | boat.Y == -1)
			{
				return false;
			}
		}
		return true;
	}




private char[][] MergeGrids(char[][] pregrid, char[][] grid)
{
    // Vérifie si les dimensions de pregrid et grid sont compatibles
    if (pregrid.Length != grid.Length || pregrid[0].Length != grid[0].Length)
    {
		Console.WriteLine($"e{pregrid.Length} & e{grid.Length}");
		return grid;
        //throw new ArgumentException("Les dimensions des grilles ne sont pas compatibles.");
    }

    // Crée une nouvelle grille de la même taille que pregrid
    char[][] mergedGrid = new char[pregrid.Length][];
    for (int i = 0; i < pregrid.Length; i++)
    {
        mergedGrid[i] = new char[pregrid[i].Length];
    }

    // Parcours toutes les cases de la grille
    for (int row = 0; row < pregrid.Length; row++)
    {
        for (int col = 0; col < pregrid[row].Length; col++)
        {
            // Si la case de grid n'est pas vide (différente de '\0')
            if (grid[row][col] != '\u0000')
            {
                // On copie la valeur de grid dans mergedGrid
                mergedGrid[row][col] = grid[row][col];
            }
            else
            {
                // Sinon, on copie la valeur de pregrid dans mergedGrid
                mergedGrid[row][col] = pregrid[row][col];
            }
        }
    }

    // Retourne la nouvelle grille fusionnée
    return mergedGrid;
}



	private MarkupString GetImageForCell(char[][] pregrid, char[][] grid1, bool?[][] maskeGrid, int x, int y)
	{
		if (pregrid.Length != grid1.Length)
		{
			previewGrid = new char[GameState.GridJ1.Length][];
			for (int i = 0; i < GameState.GridJ1.Length; i++)
			{
				previewGrid[i] = new char[GameState.GridJ1[i].Length];
			}
			return new MarkupString($"<img>");
		}
		char[][] grid = MergeGrids(pregrid, grid1);


		string imageUrl = "";
		string rotationClass = "";

		// taille de la grille
		int numberOfRows = grid.Length;
		int numberOfColumns = grid[0].Length;


		// cas ou il y a un bateau
		if (grid[x][y] != '\0')
		{
			if(maskeGrid[x][y] == null || maskeGrid[x][y] == true)
			{
				// lettre du bateau
				char letter = grid[x][y];

				// si lettre a gauche et a droite => midle
				if (y > 0 && y < numberOfColumns-1 && grid[x][y-1] == letter && grid[x][y+1] == letter){
					imageUrl = "img/middle_boat";
					rotationClass = "rotate-90";
				}
				// sinon si lettre a gauche => last
				else if (y > 0 && grid[x][y-1] == letter){
					imageUrl = "img/back_boat";
					rotationClass = "rotate-90";
				}
				// sinon si lettre a droite => first
				else if (y < numberOfColumns-1 && grid[x][y+1] == letter){
					imageUrl = "img/front_boat";
					rotationClass = "rotate-90";
				}
				// si lettre en haut et en bas => midle
				else if (x > 0 && x < numberOfRows-1 && grid[x-1][y] == letter && grid[x+1][y] == letter){
					imageUrl = "img/middle_boat";
				}
				// sinon si lettre en haut => front
				else if (x > 0 && grid[x-1][y] == letter){
					imageUrl = "img/back_boat";
				}
				// sinon si lettre en bas => last
				else if (x < numberOfRows-1 && grid[x+1][y] == letter){
					imageUrl = "img/front_boat";
				}
				else {
					imageUrl = "img/single_boat";
				}
			}
			
			if(maskeGrid[x][y] == true)
			{
				imageUrl += "_hit";
			}
		}
		// cas ou il n'y a pas de bateau
		else {

			if(maskeGrid[x][y] == false)
			{
				imageUrl = "img/miss";
			}
			else {
				return new MarkupString($"<span></span>");
			}
		}
		
		imageUrl += ".png";
		return new MarkupString($"<img src='{imageUrl}' alt='cell-image' class='img-grid {rotationClass}' />");
	}
}