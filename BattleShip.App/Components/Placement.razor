@inject GameState GameState
@using BattleShip.Models

<div class="container-placement">

	@* les différents bateaux à placer *@
	<div class="list-boat">
		
		@if(GameState.fleetJ1 != null)
		{
			@foreach (var boat in GameState.fleetJ1.Boats)
			{
				<p class="@(boat.IsAlive ? "alive" : "sunk")">
					@boat.Name - @boat.Size
				</p>

				@if(!clic)
				{
					@if(!IsPlaced(boat.Symbol))
					{
						<button class="btn btn-primary" @onclick="() => SelectBoat(boat, false)" >
							Add Vertical
						</button>
						<button class="btn btn-primary" @onclick="() => SelectBoat(boat, true)" >
							Add Horizontal
						</button>
					}
					else {
						<button class="btn btn-danger" @onclick="() => DeleteBoat(boat)" >
							Suppr
						</button>
					}
					
				}
				
			}
		}

	</div>


	@* Notre grille de placement *@
	<div class="placement-grid">
		<div class="sub-title">
			<h3>Placement</h3>
		</div>
		<div class="grid-container">
			@if (GameState != null)
			{
				@for (int row = 0; row < GameState.GridJ1.Length; row++)
				{
					var currentRow = row;
					<div class="grid-row pos-{row}">
						@for (int col = 0; col < GameState.GridJ1[0].Length; col++)
						{
							var currentCol = col;
							<div class="grid-item pos-{row}-{col} pos-{col}" @onclick="() => AddBoatToGrid(currentRow, currentCol, placementHorizontal)">
								<div class="grid-item pos-{row}-{col} pos-{col}">
									@GetImageForCell(GameState.GridJ1,GameState.MaskedGridJ1, row, col)
								</div>
							</div>
						}
					</div>
				}
			}
		</div>
	</div>

</div>


<div>
	<button class="btn btn-primary" @onclick="() => OnButtonClicked(GameState.fleetJ1)">
		Start
	</button>
</div>


@code {

	private bool clic;
	private Boat boatSelected;
	private bool placementHorizontal;

	[Parameter]
	public EventCallback<Models.Fleet> OnCallStart { get; set; }

	private async Task OnButtonClicked(Models.Fleet placedBoat)
	{
		if (OnCallStart.HasDelegate)
		{
			await OnCallStart.InvokeAsync();
		}
	}


	private void SelectBoat(Boat boat, bool isHorizontal)
	{
		clic = true;
		boatSelected = boat;
		placementHorizontal = isHorizontal;
	}


	private void AddBoatToGrid(int row, int col, bool isHorizontal)
    {
		if(clic & CanBePlaced(row, col, boatSelected.Size, isHorizontal))
		{
			Console.WriteLine(CanBePlaced(row, col, boatSelected.Size, isHorizontal));
			for (int i = 0; i < boatSelected.Size; i++)
			{
				if(isHorizontal)
				{
					GameState.GridJ1[row][col+i] = boatSelected.Symbol;
				}
				else {
					GameState.GridJ1[row+i][col] = boatSelected.Symbol;
				}
			}
			boatSelected.X = row;
			boatSelected.Y = col;
			boatSelected.Horizontal = isHorizontal;
			clic = false;
		}
		
    }

	private void DeleteBoat(Boat boat)
	{
		for (int i = 0; i < boat.Size; i++)
		{
			if(boat.Horizontal)
			{
				GameState.GridJ1[boat.X][boat.Y+i] = '\u0000';
			}
			else {
				GameState.GridJ1[boat.X+i][boat.Y] = '\u0000';
			}
		}
		boat.X = -1;
		boat.Y = -1;
	}


	private bool IsPlaced(char symbol)
	{
		for (int row = 0; row < GameState.GridJ1.Length; row++)
		{
			for (int col = 0; col < GameState.GridJ1[row].Length; col++)
			{
				if (GameState.GridJ1[row][col] == symbol)
				{
					return true; 
				}
			}
		}
		return false;
	}


	private bool CanBePlaced(int row, int col, int size, bool isHorizontal)
	{
		if(isHorizontal) {
			if(col+size > GameState.GridJ1.Length | col < 0) {
				return false;
			}
		}
		else {
			if(row+size > GameState.GridJ1.Length | row < 0) {
				return false;
			}
		}
		return true;
	}




	private MarkupString GetImageForCell(char[][] grid, bool?[][] maskeGrid, int x, int y)
	{

		string imageUrl = "";
		string rotationClass = "";

		// taille de la grille
		int numberOfRows = grid.Length;
		int numberOfColumns = grid[0].Length;


		// cas ou il y a un bateau
		if (grid[x][y] != '\0')
		{
			if(maskeGrid[x][y] == null || maskeGrid[x][y] == true)
			{
				// lettre du bateau
				char letter = grid[x][y];

				// si lettre a gauche et a droite => midle
				if (y > 0 && y < numberOfColumns-1 && grid[x][y-1] == letter && grid[x][y+1] == letter){
					imageUrl = "img/middle_boat";
					rotationClass = "rotate-90";
				}
				// sinon si lettre a gauche => last
				else if (y > 0 && grid[x][y-1] == letter){
					imageUrl = "img/back_boat";
					rotationClass = "rotate-90";
				}
				// sinon si lettre a droite => first
				else if (y < numberOfColumns-1 && grid[x][y+1] == letter){
					imageUrl = "img/front_boat";
					rotationClass = "rotate-90";
				}
				// si lettre en haut et en bas => midle
				else if (x > 0 && x < numberOfRows-1 && grid[x-1][y] == letter && grid[x+1][y] == letter){
					imageUrl = "img/middle_boat";
				}
				// sinon si lettre en haut => front
				else if (x > 0 && grid[x-1][y] == letter){
					imageUrl = "img/back_boat";
				}
				// sinon si lettre en bas => last
				else if (x < numberOfRows-1 && grid[x+1][y] == letter){
					imageUrl = "img/front_boat";
				}
				else {
					imageUrl = "img/single_boat";
				}
			}
			
			if(maskeGrid[x][y] == true)
			{
				imageUrl += "_hit";
			}
		}
		// cas ou il n'y a pas de bateau
		else {

			if(maskeGrid[x][y] == false)
			{
				imageUrl = "img/miss";
			}
			else {
				return new MarkupString($"<span></span>");
			}
		}
		
		imageUrl += ".png";
		return new MarkupString($"<img src='{imageUrl}' alt='cell-image' class='img-grid {rotationClass}' />");
	}
}